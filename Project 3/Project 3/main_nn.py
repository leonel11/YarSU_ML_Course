## Практическое задание № 3. Многоклассовая классификация и нейронные сети (нейронная сеть)

# Инициализация
import numpy as np
import scipy.io as spi
import matplotlib.pyplot as plt

from displayData import displayData
from predictNN import predictNN

# ================= Часть 1. Визуализация данных =================

print('Часть 1. Визуализация данных')

# Загрузка данных и формирование матрицы объекты-признаки X и вектора меток y
data = spi.loadmat('data.mat')

X = data['X']
y = data['y']

m, n = X.shape

# Визуализация данных
rand_indices = np.random.permutation(range(m))
sel = X[rand_indices[0:100], :]

displayData(sel, 10)

input('Программа остановлена. Нажмите Enter для продолжения ... \n')

# = Часть 2. Загрузка параметров модели обученной нейронной сети =

print('Часть 2. Загрузка параметров модели обученной нейронной сети')

# Загрузка параметров
weights = spi.loadmat('weights.mat')

# Архитектура рассматриваемой нейронной сети является следующей
# 1. Число слоев: 3
# 2. Число нейронов во входном слое: 400 (равно числу признаков) без учета компоненты смещения
# 3. Число нейронов в скрытом слое:  25 без учета компоненты смещения
# 4. Число нейронов в выходном слое: 10 (равно числу классов)
# 5. Функция активации нейронов скрытого и выходного слоев: сигмоидная

Theta1 = weights['Theta1'] # размер матрицы 25 x 401
Theta2 = weights['Theta2'] # размер матрицы 10 x 26

input('Программа остановлена. Нажмите Enter для продолжения ... \n')

# == Часть 3. Вычисление доли правильных ответов классификатора ==

print('Часть 3. Вычисление доли правильных ответов классификатора')

X = np.concatenate((np.ones((m, 1)), X), axis = 1)

# Вычисление доли правильных ответов классификатора
p = predictNN(X, Theta1, Theta2)
acc = np.sum((p == y).astype('float64')) / len(y) * 100
print('Доля правильных ответов обученного классификатора = {:.4f}'.format(acc))

input('Программа остановлена. Нажмите Enter для продолжения ... \n')

# = Часть 4. Визуализация цифры и предсказанного значения класса =

print('Часть 4. Визуализация цифры и предсказанного значения класса')

rp = np.random.permutation(range(m))

for i in range(m):
    p = predictNN(np.array([X[rp[i], :]]), Theta1, Theta2)
    print('Истинное и предсказанное значения метки класса:', y[rp[i], 0], '|', p[0, 0])
    displayData(np.array([X[rp[i], 1:n+1]]), 1)